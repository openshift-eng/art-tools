import hashlib
import json
import random
import typing
import uuid
from datetime import datetime
from enum import Enum

from google.cloud.bigquery.table import Row

from artcommonlib import logutil

LOGGER = logutil.get_logger(__name__)


class KonfluxBuildOutcome(Enum):
    FAILURE = 'failure'
    SUCCESS = 'success'


class ArtifactType(Enum):
    RPM = 'rpm'
    IMAGE = 'image'


class Engine(Enum):
    KONFLUX = 'konflux'
    BREW = 'brew'


class KonfluxBuild:
    """
    This class represents the data structure we use to store build information in Konflux
    By calling the konfluxdb.support.konflux_build.generate_build_schema() function,
    a table schema can be auto-generated from this class definition.
    The schema we get can then be injected into the konfluxdb.support.konflux_db.SupportKonfluxDb.create_table()
    function, that will create the table in BigQuery for us.

    In order for this to work, this class should contain no fields other than those we want to appear as table columns.
    """

    # These fields are excluded when computing the build ID, but are included in the build string representation
    EXCLUDED_KEYS = [
        'record_id',
        'build_id',
        'nvr',
    ]

    def __init__(self, name: str = '', group: str = '', version: str = '', release: str = '', assembly: str = '',
                 el_target: str = '', arch: str = '', rpms: list = [], parent_images: list = [], source_repo: str = '',
                 commitish: str = '', embargoed: bool = False, start_time: datetime = None, end_time: datetime = None,
                 artifact_type: ArtifactType = ArtifactType.IMAGE, engine: Engine = Engine.KONFLUX, image_tag: str = '',
                 outcome: KonfluxBuildOutcome = KonfluxBuildOutcome.SUCCESS, job_url: str = '',
                 pipeline_commit: str = '', schema_version: int = 0, ingestion_time: datetime = None,
                 record_id: str = '', build_id: str = None, nvr: str = None):
        """
        All fields default to None to facilitate testing
        """

        self.name = name
        self.group = group
        self.version = version
        self.release = release
        self.assembly = assembly
        self.el_target = el_target
        self.arch = arch

        self.rpms = rpms
        self.parent_images = parent_images

        self.source_repo = source_repo
        self.commitish = commitish

        self.embargoed = embargoed

        self.start_time = start_time
        self.end_time = end_time

        self.artifact_type = artifact_type if isinstance(artifact_type, ArtifactType) else ArtifactType(artifact_type)
        self.engine = engine if isinstance(engine, Engine) else Engine(engine)

        self.image_tag = image_tag
        self.outcome = outcome if isinstance(outcome, KonfluxBuildOutcome) else KonfluxBuildOutcome(outcome)

        self.job_url = job_url
        self.pipeline_commit = pipeline_commit

        self.schema_version = schema_version

        # A build will correspond to multiple records, as Doozer will first create a build record with PENDING state.
        # Once the pipeline completed, a new record will be created for the same build, with the final build outcome.
        # Two records for the same build will share the same build_id, but will have different record_ids
        # ingestion_time is set by Doozer and will let us select the most recent record
        # The NVR can be used as a compact, human-readable name for the build
        self.ingestion_time = ingestion_time
        self.record_id = record_id if record_id else self.generate_record_id()
        self.build_id = build_id if build_id else self.generate_build_id()
        self.nvr = nvr if nvr else self.get_nvr()

    def __str__(self):
        return json.dumps(self.to_dict(), indent=4)

    def to_dict(self) -> dict:
        """
        Returns a dict object representing the build data.
        KonfluxDb.add_builds() can use data in this form to store the build info into the DB.
        """

        return {
            key: (value.strftime("%Y-%m-%dT%H:%M:%S") if isinstance(value, datetime)
                  else value.value if isinstance(value, Enum) else value)
            for key, value in self.__dict__.items()
        }

    def generate_build_id(self) -> str:
        """
        The build ID is generated by hashing the string representation of a build object.
        Since 2 different builds cannot have the same exact fields, this should protect us from collisions.
        """

        build_repr = {key: val for key, val in self.to_dict().items() if key not in self.EXCLUDED_KEYS}
        return self._generate_uuid(hashlib.sha256(json.dumps(build_repr).encode()).digest())

    @classmethod
    def generate_record_id(cls) -> str:
        """
        Generates a unique ID for every record. Two records referring to the same build will always have distinct IDs
        """

        random_data = str(random.getrandbits(256)).encode()
        return cls._generate_uuid(hashlib.sha256(random_data).digest())

    @staticmethod
    def _generate_uuid(hash_bytes: bytes):
        return str(uuid.UUID(bytes=hash_bytes[:16]))

    def get_nvr(self):
        self.nvr = f'{self.name}-{self.version}-{self.release}'
        return self.nvr


def from_result_row(row: Row) -> typing.Optional[KonfluxBuild]:
    """
    Given a google.cloud.bigquery.table.Row object, construct and return a KonfluxBuild object
    """

    try:
        return KonfluxBuild(**{
            field: (row[field])
            for field in row.keys()
        })

    except AttributeError as e:
        LOGGER.error('Could not construct a KonfluxBuild object from result row %s: %s', row, e)
        raise
