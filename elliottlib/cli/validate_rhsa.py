from elliottlib import brew, constants, errata, Runtime
from elliottlib.cli.common import cli
from elliottlib.util import exit_unauthenticated

from errata_tool import Erratum
import click
import json
import koji
import requests
import textwrap
pass_runtime = click.make_pass_decorator(Runtime)


@cli.command("validate-rhsa", short_help="Validate RHSA with Product Security checks")
@click.argument('advisory', type=int)
@pass_runtime
def validate_rhsa_cli(runtime, advisory):
    """
    Validates an RHSA by returning the 'alerts' generated by Product Security's central SFM2 server.

    Usage:
\b
    $ elliott validate-rhsa ID
"""

    if Erratum(errata_id=advisory).errata_type != 'RHSA':
        print(f"Advisory {advisory} is not an RHSA. Nothing to check.")
        exit(0)

    session = requests.Session()
    url = constants.SFM2_ERRATA_ALERTS_URL.format(id=advisory)
    print(url)
    print("Validating..")
    print()
    resp = session.get(url)

    # Will fail if id invalid, not an RHSA or RHSA has embargoed data
    if resp.status_code != 200:
        print(f"HTTP {resp.status_code}: Could not validate rhsa {advisory} (is it an RHSA? without embargo?)")
        exit(1)
        return

    alerts = resp.json()

    ignores = [
        'ErratumValidator.check_spelling',
        'ErratumValidator.check_multiple_builds',
        'ErratumValidator.check_ps_review_presence'
    ]
    actionable_alerts = []
    for alert in alerts:
        if alert.get('rule_name') in ignores:
            continue
        if alert.get('rule_name') == 'ErratumValidator.check_erratum_text_fields' and alert.get('text', '').startswith('Typo: '):
            continue
        actionable_alerts.append(alert)

    if actionable_alerts:
        for a in actionable_alerts:
            print("E: {text}".format(text=a.get("text")))
            howto = a.get("how_to_resolve")
            if howto:
                print(textwrap.indent(howto, "  > "))
            print()
        exit(2)
    else:
        print("No issues found")
